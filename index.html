<!DOCTYPE html>
<html>

<head>
    <title>Radiation 3D prototype</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
        }



        #functionbox {
            width: 250px;
            height: auto;
            position: absolute;
            top: 50px;
            left: 10px;
            z-index: 100;

            background-color: #b5cea8;
            background-color: #4444447e;
            border-radius: 4px;
        }

        #renderbody {
            width: 100%;
            height: 100vh;
        }

        #deleteplane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #deleteplane:hover {
            background: #007e7a;
        }

        #deleteplane:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .custom-file-upload {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: 22px;
            padding: 8px 16px;
            background: #00a19b;
            width: 168px;
            height: 32px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .custom-file-upload:hover {
            background-color: #007e7a;
        }

        .custom-file-upload:active {
            transform: scale(0.97);
        }

        #addplane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #addplane:hover {
            background: #007e7a;
        }

        #top {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 400;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 0px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #top:hover {
            background: #007e7a;
        }

        #front {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 8px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #front:hover {
            background: #007e7a;
        }

        #side {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 400;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 8px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #side:hover {
            background: #007e7a;
        }

        #perspective {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #perspective:hover {
            background: #007e7a;
        }

        #renderbody {
            position: relative;
            width: 100%;
            height: 100vh;
            margin: 0;
            padding: 0;
        }

        /* Add this to your existing style section */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        #valueDisplay {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 1001;
            white-space: nowrap;
        }

        .modal-content {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            cursor: zoom-in;
            max-width: 90vw;
            max-height: 90vh;
        }

        .close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
        }

        #scalinginput {
            padding: 6px 8px;
            font-size: 20px;
            font-family: 'Poppins', sans-serif;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            margin-left: 25px;
            width: 200px;
            max-width: 185px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        #scalinginput:placeholder {
            color: #aaa;
        }

        #scalinginput:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2);
        }

        #scalingbutton {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #scalingbutton:hover {
            background: #007e7a;
        }

        #updatescale {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #updatescale:hover {
            background: #007e7a;
        }

        #exportBtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #exportBtn:hover {
            background: #007e7a;
        }

        #resetPlane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #resetPlane:hover {
            background: #007e7a;
        }


        #importbtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: 24px;
            padding: 8px 16px;
            background: #00a19b;
            width: 168px;
            height: 32px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #importbtn:hover {
            background-color: #007e7a;
        }

        #importbtn:active {
            transform: scale(0.97);
        }

        #detail {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #detail:hover {
            background: #007e7a;
        }


        #contourgenerator {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #contourgenerator:hover {
            background: #007e7a;
        }


        #calculate {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #calculate:hover {
            background: #007e7a;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            outline: none;
        }

        hr {
            border: none;
            border-top: 1px solid #444;
            margin: 10px 0;
        }

        p {
            font: bolder;
            font-size: 24px;
            font-family: 'Poppins', sans-serif;
            text-align: center;
            margin: 5px 0 10px 0;
            font-weight: bold;
            color: aliceblue;
        }

        .my-custom-gui {
            font-size: 26px;
            width: 700px;
            background-color: #222;
            border-radius: 10px;
            padding: 20px;
        }

        /* Bigger dat.GUI with your color scheme */
        .dg.main {
            font-family: 'Poppins', sans-serif !important;
            font-size: 20px !important;
            background-color: rgba(68, 68, 68, 0.8) !important;
            border-radius: 4px !important;
            width: 500px !important;
        }

        .dg .cr {
            height: 40px !important;
            line-height: 40px !important;
            border-bottom: 1px solid #444 !important;
        }

        .dg .c input[type=text] {
            height: 28px !important;
            font-size: 20px !important;
            background: #555 !important;
            color: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            font-family: 'Poppins', sans-serif;
            font: 700;
            width: 100% !important;
            margin-left: 0 !important;
        }

        .dg .c .slider {
            display: none !important;
        }

        .dg .c .slider-fg {
            background: #00a19b !important;
            height: 24px !important;
        }

        .dg .c .slider:hover .slider-fg {
            background: #007e7a !important;
        }

        .dg .title {
            font-size: 18px !important;
            padding: 8px 10px !important;
            background-color: rgba(0, 161, 155, 0.3) !important;
        }

        .dg .cr.function .property-name {
            color: white !important;
            font-weight: 500 !important;
        }

        .dg .cr.function:hover {
            background: rgba(0, 161, 155, 0.2) !important;
        }

        .dg .cr.number .property-name,
        .dg .cr.boolean .property-name {
            color: white !important;
            font-weight: 500 !important;
        }

        .dg.main .close-button {
            display: none !important;
        }

        .dg.main .close-button:hover {
            background-color: #007e7a !important;
        }

        .view-buttons-container {
            display: flex;
            justify-content: center;
        }
    </style>

</head>

<body>

    <div id="functionbox">
        <p>Floor plan</p>
        <input type="file" id="imageInput" accept="image/*" hidden>
        <label for="imageInput" class="custom-file-upload">Upload Image</label>
        <hr>
        <p>Plane</p>
        <button id="addplane"> Add Plane </button>
        <button id="deleteplane">Delete Plane </button>
        <button id="resetPlane">Reset Plane</button>
        <hr>
        <p>Views</p>
        <div class="view-buttons-container">
            <button id="top">Top</button>
            <button id="front"> Front</button>
            <button id="side">Side</button>
        </div>
        <button id="perspective">Perspective</button>
        <hr>
        <p>Scaling</p>
        <input type="text" name="Set scale" id="scalinginput" placeholder="Enter the distance">
        <button id="scalingbutton"> Set scale </button>
        <button id="updatescale"> Update </button>
        <hr>
        <p>Save</p>
        <button id="exportBtn"> Export Scene</button>
        <input type="file" id="importFile" accept=".json" hidden>
        <label for="importFile" id="importbtn"> Import Scene </label>
        <hr>
        <p>Calculation</p>
        <button id="detail">Show detail</button>
        <button id="contourgenerator">Contour</button>
        <button id="calculate">Calculate</button>

    </div>
    <svg id="contour-svg" width="512" height="512" style="display:none;"></svg>
    <div id="renderbody"></div>
    <div id="contourModal" class="modal">
        <span class="close">&times;</span>
        <div id="valueDisplay"></div>
        <img id="contourImage" class="modal-content">
    </div>
    <svg id="contour-svg" width="512" height="512" style="display:none;"></svg>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-contour@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/LineSegmentsGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/LineSegments2.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/LineGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/LineMaterial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/Line2.js"></script>

    <script>



        // Add these variables near the top with your other variables
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY_STEPS = 500; // Prevent memory bloat
        function initializeHistory() {
            // Capture initial empty state
            const initialState = planes.map(plane => ({
                position: plane.mesh.position.clone(),
                rotation: plane.mesh.rotation.clone(),
                scale: plane.mesh.scale.clone(),
                width: plane.width,
                height: plane.height,
                color: plane.color,
                temperature: plane.temperature,
                name: plane.name
            }));

            history = [initialState];
            historyIndex = 0;
            console.log("Initial history state captured");
        }


        // Add undo/redo functions
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                console.log(`Undo to state ${historyIndex + 1}/${history.length}`);
                restoreState(historyIndex);
            } else {
                console.log("Already at earliest state");
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                console.log(`Redo to state ${historyIndex + 1}/${history.length}`);
                restoreState(historyIndex);
            } else {
                console.log("Already at latest state");
            }
        }

        // Replace the current keyboard event listener with this:
        window.addEventListener('keydown', (event) => {
            if (event.ctrlKey || event.metaKey) {
                if (event.key === 'z' && !event.shiftKey) {
                    undo();
                    event.preventDefault();
                } else if ((event.key === 'y' || (event.shiftKey && event.key === 'z'))) {
                    redo();
                    event.preventDefault();
                }
            }
        });

        // Add event listeners for buttons
        document.getElementById('undoBtn')?.addEventListener('click', undo);
        document.getElementById('redoBtn')?.addEventListener('click', redo);

        // Now we need to capture states at key moments. Add these calls:

        const scene = new THREE.Scene();
        scene.background = new THREE.Color("#222");


        //set up different camera parameters
        const frustumSize = 40;
        const cameras = {
            perspective: new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000),
            top: new THREE.OrthographicCamera(),
            front: new THREE.OrthographicCamera(),
            left: new THREE.OrthographicCamera()
        }

        cameras.perspective.position.set(10, 10, 10);
        cameras.top.position.set(0, 10, 0);
        cameras.top.lookAt(0, 0, 0);
        cameras.front.position.set(0, 0, 10);
        cameras.front.lookAt(0, 0, 0);
        cameras.left.position.set(-10, 0, 0);
        cameras.left.lookAt(0, 0, 0);

        for (const key in cameras) cameras[key].lookAt(0, 0, 0);
        let activeCamera = cameras.perspective;

        function updateOrthoCameras() {
            const aspect = window.innerWidth / window.innerHeight;
            for (const key of ['top', 'front', 'left']) {
                const cam = cameras[key];
                cam.left = frustumSize * aspect / -2; cam.right = frustumSize * aspect / 2;
                cam.top = frustumSize / 2; cam.bottom = frustumSize / -2;
                cam.near = 0.1; cam.far = 1000;
                cam.updateProjectionMatrix();
            }
        }

        updateOrthoCameras();

        document.getElementById('perspective').addEventListener('click', () => setView(cameras.perspective));
        document.getElementById('top').addEventListener('click', () => {
            setView(cameras.top)
        });
        document.getElementById('front').addEventListener('click', () => {
            setView(cameras.front)
        });
        document.getElementById('side').addEventListener('click', () => {
            setView(cameras.left)
        });

        // At the top with your other variables
        let selectedPlanes = []; // Array to store multiple selected planes
        let isShiftPressed = false; // Track shift key state
        // Add these near your other variables
        let selectedPlaneGroup = null; // Will store the temporary group
        let originalPositions = new Map(); // Stores original positions before grouping

        // Add these near your other event listeners (like the keydown for transform controls)
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Shift') {
                isShiftPressed = true;
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') {
                isShiftPressed = false;
            }
        });


        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("renderbody").appendChild(renderer.domElement);


        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);


        // Add a grid (hidden by default)
        const grid = new THREE.GridHelper(50, 50, 0xffffff, 0xffffff);
        scene.add(grid);

        // Create a plane for the image (initially invisible)
        const planeGeometry = new THREE.PlaneGeometry(10, 10);
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
        const imagePlane = new THREE.Mesh(planeGeometry, planeMaterial);
        imagePlane.rotation.x = -Math.PI / 2; // Rotate to lie flat
        imagePlane.visible = false; // Hide until image loads
        scene.add(imagePlane);

        // OrbitControls for interaction
        const controls = new THREE.OrbitControls(activeCamera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.4;

        controls.update();

        function setView(camera) {

            controls.reset();

            activeCamera = camera;
            controls.object = camera;
            transformControlss.camera = camera;

            if (camera === cameras.top) {
                camera.position.set(0, 10, 0);
                camera.lookAt(0, 0, 0);
            } else if (camera === cameras.front) {
                camera.position.set(0, 0, 10);
                camera.lookAt(0, 0, 0);
            } else if (camera === cameras.left) {
                camera.position.set(-10, 0, 0);
                camera.lookAt(0, 0, 0);
            }

            // Update projection matrices
            if (camera.isOrthographicCamera) {
                updateOrthoCameras();
            }

            // Toggle wireframe based on view
            const isTopView = (camera === cameras.top);

            // First, clean up any existing wireframe lines from all planes
            planes.forEach(plane => {
                if (plane.mesh.userData.wireframeLine) {
                    scene.remove(plane.mesh.userData.wireframeLine);
                    plane.mesh.userData.wireframeLine = null;
                }
                plane.mesh.visible = true; // Make sure all planes are visible by default
            });

            // If in top view, create new wireframe lines
            if (isTopView) {
                planes.forEach(plane => {
                    // Convert to Line2 for thicker wireframe
                    const geometry = plane.mesh.geometry;
                    const edges = new THREE.EdgesGeometry(geometry);

                    // Create Line2 geometry
                    const positions = [];
                    const attrPos = edges.getAttribute('position');
                    for (let i = 0; i < attrPos.count; i++) {
                        positions.push(attrPos.getX(i), attrPos.getY(i), attrPos.getZ(i));
                    }

                    const lineGeometry = new THREE.LineGeometry();
                    lineGeometry.setPositions(positions);

                    // Create Line2 material with thicker lines
                    const lineMaterial = new THREE.LineMaterial({
                        color: 0xff0000,
                        linewidth: 0.01, // Thicker line width
                        dashed: false
                    });

                    // Create the Line2 object
                    const line = new THREE.Line2(lineGeometry, lineMaterial);
                    line.computeLineDistances();
                    line.scale.set(1, 1, 1);

                    // Store reference to the line so we can remove it later
                    plane.mesh.userData.wireframeLine = line;

                    // Add to scene and hide the original mesh
                    line.position.copy(plane.mesh.position);
                    line.rotation.copy(plane.mesh.rotation);
                    scene.add(line);
                    plane.mesh.visible = false;
                });
            }

            if (camera.isPerspectiveCamera) {
                controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
                controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
                controls.enableRotate = true;
            } else {
                controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
                controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
                controls.enableRotate = false;
            }
            controls.update();
        }
        // setView(activeCamera);

        let scalingcheck = false;
        let aspect = null;

        // 5. Handle image upload
        document.getElementById("imageInput").addEventListener("change", imageupload);

        let targetHeight = 10;

        function imageupload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Check if file is an image (PNG, JPG, etc.)
            if (!file.type.match("image.*")) {
                alert("Please upload an image file (PNG, JPG, etc.)");
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const imageUrl = e.target.result;

                //to read the image dimension 
                const img = new Image();
                img.onload = function () {
                    aspect = img.width / img.height;
                    const targetHeight = 10;
                    const targetWidth = targetHeight * aspect;

                    imagePlane.geometry.dispose();
                    imagePlane.geometry = new THREE.PlaneGeometry(targetWidth, targetHeight);
                }
                const texture = new THREE.TextureLoader().load(imageUrl, function (texture) {
                    // Success: Apply texture to the plane
                    imagePlane.material.map = texture;
                    imagePlane.material.needsUpdate = true;
                    imagePlane.visible = true;
                    grid.visible = true; // Hide grid
                }, undefined, (error) => {
                    console.error("Error loading image:", error);
                    alert("Failed to load image. Try another file.");
                });
                img.src = imageUrl;
            };
            reader.onerror = (error) => {
                console.error("FileReader error:", error);
                alert("Error reading file. Try again.");
            };
            reader.readAsDataURL(file);
        }

        // Array to store all planes
        const planes = [];
        let selectedPlane = null;
        let gui = new dat.GUI();
        gui.domElement.classList.add("my-custom-gui");
        let transformControls = null;

        //new bit for scaling
        let isMeasuring = false;
        let measurePoints = [];

        function handleMeasurementClick(event) {
            if (!isMeasuring) return;

            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, cameras.top);

            // Check intersections with all scene objects (more reliable)
            const intersects = raycaster.intersectObject(imagePlane);
            let distance = null;

            if (intersects.length > 0) {
                const point = intersects[0].point;
                measurePoints.push(point);
                console.log(`Point ${measurePoints.length} recorded at:`, point);

                if (measurePoints.length === 2) {
                    distance = measurePoints[0].distanceTo(measurePoints[1]);
                    console.log(`Distance between points: ${distance.toFixed(2)} units`);

                    cleanupMeasurement();
                }
            }
            return distance;
        }

        function cleanupMeasurement() {
            measurePoints = [];
            isMeasuring = false;
            renderer.domElement.removeEventListener('click', handleMeasurementClick);
        }

        function handleScalingClick(event) {
            scalingdist = handleMeasurementClick(event);
        }

        let scalingdist = null;
        document.getElementById("scalingbutton").addEventListener("click", function () {
            setView(cameras.top);
            isMeasuring = true;
            scalingcheck = true;
            measurePoints = [];
            console.log("Ready to measure - click two points in the scene");

            // Add temporary click listener
            renderer.domElement.removeEventListener('click', handleScalingClick);
            renderer.domElement.addEventListener('click', handleScalingClick);
        });

        document.getElementById("updatescale").addEventListener("click", function () {
            const inputvalue = document.getElementById("scalinginput").value;
            if (!inputvalue) {
                alert("please key in the scale first")
            }
            else {
                updatemeasureplane(inputvalue);
            }
        })

        function updatemeasureplane(input) {
            if (!scalingdist || !aspect) {
                console.error("Measurement data not available");
                return;
            }

            // Calculate scaling factor
            let scalingfactor = input / scalingdist;
            const newtargetHeight = targetHeight * scalingfactor;
            const newtargetWidth = newtargetHeight * aspect;

            targetHeight = newtargetHeight;

            // Preserve current material and visibility
            const currentMaterial = imagePlane.material;
            const currentVisibility = imagePlane.visible;
            const currentPosition = imagePlane.position.clone();
            const currentRotation = imagePlane.rotation.clone();

            // Dispose old geometry and create new one
            imagePlane.geometry.dispose();
            imagePlane.geometry = new THREE.PlaneGeometry(newtargetWidth, newtargetHeight);

            // Restore properties
            imagePlane.material = currentMaterial;
            imagePlane.visible = currentVisibility;
            imagePlane.position.copy(currentPosition);
            imagePlane.rotation.copy(currentRotation);

            console.log("Plane updated with new dimensions:", newtargetWidth, newtargetHeight);
        }


        // Function to create a new plane
        function createPlane(width = 1, height = 1) {
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color(Math.random() * 0xffffff),
                side: THREE.DoubleSide,
                wireframe: false,
            });

            const plane = new THREE.Mesh(geometry, material);
            plane.position.set(0, 0, 0);
            plane.rotation.y = Math.PI * 2;
            plane.scale.set(1, 1, 1);
            const defaultName = `Plane ${planes.length + 1}`;
            // Store plane data
            const planeData = {
                mesh: plane,
                width: width,
                height: height,
                // Store default values
                defaultWidth: width,
                defaultHeight: height,
                defaultX: 0,
                defaultY: height / 2,
                defaultZ: 0,
                defaultAngle: 0,
                defaultColor: material.color.getHex(),
                name: defaultName,
                x: plane.position.x,
                y: plane.position.y,
                z: plane.position.z,
                angle: plane.rotation.y * 180 / Math.PI,
                incline: plane.rotation.x * 180 / Math.PI,
                color: material.color.getHex(),
                temperature: 30
            };

            planes.push(planeData);
            scene.add(plane);

            // Make plane selectable
            plane.userData = planeData;
            if (history.length === 0) {
                initializeHistory();
            }
            captureState(true);
            return planeData;

        }

        function resetPlaneToDefault() {
            if (selectedPlanes.length === 0) {
                alert("Please select at least one plane first");
                return;
            }

            captureState();
            
            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            selectedPlanes.forEach(planeData => {
                // Reset all properties to defaults
                planeData.width = 1;
                planeData.height = 1;
                planeData.x = 0;
                planeData.y = 0.5;
                planeData.z = 0;
                planeData.angle = 0;
                planeData.incline = 0; // Reset incline to 0
                planeData.color = planeData.defaultColor;

                // Update the mesh
                planeData.mesh.geometry.dispose();
                planeData.mesh.geometry = new THREE.PlaneGeometry(
                    planeData.width,
                    planeData.height
                );

                planeData.mesh.position.set(
                    planeData.x,
                    planeData.y,
                    planeData.z
                );
                planeData.mesh.rotation.set(
                    planeData.incline * Math.PI / 180, // x rotation (incline)
                    planeData.angle * Math.PI / 180,   // y rotation (angle)
                    0                                  // z rotation
                );
                planeData.mesh.scale.set(1, 1, 1);
                planeData.mesh.material.color.setHex(planeData.color);
            });

            // Update the GUI
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }

            captureState();
        }

        // Add event listener for the reset button
        document.getElementById("resetPlane").addEventListener("click", resetPlaneToDefault);

        function deleteplanefn() {
            if (selectedPlanes.length === 0) return;

            // Delete all selected planes
            selectedPlanes.forEach(planeData => {
                if (transformControlss.object === planeData.mesh) {
                    transformControlss.detach();
                }

                scene.remove(planeData.mesh);

                const index = planes.indexOf(planeData);
                if (index > -1) {
                    planes.splice(index, 1);
                }

                planeData.mesh.geometry.dispose();
                planeData.mesh.material.dispose();
            });

            gui.destroy();
            gui = new dat.GUI();
            selectedPlanes = [];
            captureState();
        }

        document.getElementById("deleteplane").addEventListener("click", deleteplanefn);

        // Function to update GUI for selected plane
        function updateGUI(planeData) {
            gui.destroy();
            gui = new dat.GUI();

            const nameController = gui.add(planeData, 'name').name('Name');
            nameController.onChange(function (newName) {
                const nameExists = planes.some(p => p !== planeData && p.name === newName);
                if (nameExists) {
                    alert('This name already exists! Please choose a different name.');
                    nameController.setValue(planeData.name);
                    return;
                }
                planeData.name = newName;
                captureState();
            });

            // Add controllers with explicit state capture
            const controllers = {
                width: gui.add(planeData, 'width').name('Width').step(0.1),
                height: gui.add(planeData, 'height').name('Height').step(0.1),
                x: gui.add(planeData, 'x').name('X-position').step(0.1),
                y: gui.add(planeData, 'y').name('Y-position').step(0.1),
                z: gui.add(planeData, 'z').name('Z-position').step(0.1),
                angle: gui.add(planeData, 'angle', -180, 180).name('Rotation').step(1),
                incline: gui.add(planeData, 'incline', -180, 180).name("Inclination").step(1),
                temp: gui.add(planeData, "temperature").name("Temperature")
            };

            // Track previous values
            controllers.width.__oldValue = planeData.width;
            controllers.height.__oldValue = planeData.height;

            // Single onChange handler for all properties
            function handleGUIChange() {
                // Handle geometry changes
                if (controllers.width.__oldValue !== planeData.width ||
                    controllers.height.__oldValue !== planeData.height) {

                    planeData.defaultWidth = planeData.width;
                    planeData.defaultHeight = planeData.height;

                    planeData.mesh.geometry.dispose();
                    planeData.mesh.geometry = new THREE.PlaneGeometry(
                        planeData.width,
                        planeData.height
                    );

                    planeData.mesh.scale.set(1, 1, 1);

                    controllers.width.__oldValue = planeData.width;
                    controllers.height.__oldValue = planeData.height;
                }

                // Update position and rotation
                planeData.mesh.position.set(planeData.x, planeData.y, planeData.z);
                planeData.mesh.rotation.set(
                    planeData.incline * Math.PI / 180,
                    planeData.angle * Math.PI / 180,
                    0
                );

                // Always capture state after any change
                captureState();
            }

            // Add listeners to all controllers
            Object.values(controllers).forEach(controller => {
                if (controller.onChange) {
                    controller.onChange(handleGUIChange);
                }
            });
        }


        renderer.domElement.addEventListener('click', (event) => {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, activeCamera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            // Clear previous group if not holding shift and clicking empty space
            if (!isShiftPressed && selectedPlaneGroup && intersects.length === 0) {
                ungroupPlanes();
                return;
            }

            for (let i = 0; i < intersects.length; i++) {
                const object = intersects[i].object;

                // Find the plane data (might be a child of the group)
                let planeData = null;
                if (object.userData && planes.some(p => p.mesh === object)) {
                    planeData = object.userData;
                } else if (object.parent && object.parent.userData && planes.some(p => p.mesh === object.parent)) {
                    planeData = object.parent.userData;
                }

                if (planeData) {
                    if (isShiftPressed) {
                        // Shift+click - toggle selection
                        const index = selectedPlanes.indexOf(planeData);
                        if (index === -1) {
                            // Add to selection
                            selectedPlanes.push(planeData);
                            planeData.mesh.material.color.setHex(0xffff00);

                            // If we have multiple planes selected, create/update group
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            }
                        } else {
                            // Remove from selection - but don't remove from scene!
                            selectedPlanes.splice(index, 1);
                            planeData.mesh.material.color.setHex(planeData.color);

                            // Update group if we still have multiple planes
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            } else {
                                ungroupPlanes();
                            }
                        }
                    } else {
                        // Regular click - single selection
                        ungroupPlanes();
                        planes.forEach(p => p.mesh.material.color.setHex(p.color));
                        selectedPlanes = [planeData];
                        planeData.mesh.material.color.setHex(0xffff00);
                    }

                    // Update transform controls
                    updateTransformControls();
                    return;
                }
            }

            // Clicked on empty space without shift - clear selection
            if (!isShiftPressed) {
                ungroupPlanes();
                planes.forEach(p => p.mesh.material.color.setHex(p.color));
                selectedPlanes = [];
                transformControlss.detach();
                gui.destroy();
                gui = new dat.GUI();
            }
        });

        function updateTransformControls() {
            if (selectedPlanes.length === 0) {
                transformControlss.detach();
                gui.destroy();
                gui = new dat.GUI();
            } else if (selectedPlaneGroup) {
                // Control the group if we have one
                transformControlss.attach(selectedPlaneGroup);
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            } else {
                // Control the last selected plane
                transformControlss.attach(selectedPlanes[selectedPlanes.length - 1].mesh);
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }
        }
        function createOrUpdateGroup() {
            // If no group exists, create one
            if (!selectedPlaneGroup) {
                selectedPlaneGroup = new THREE.Group();
                scene.add(selectedPlaneGroup);

                // Store original positions and parents
                originalPositions = new Map();
                selectedPlanes.forEach(plane => {
                    // Store the world position and original parent
                    const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                    originalPositions.set(plane, {
                        worldPosition: worldPos.clone(),
                        parent: plane.mesh.parent
                    });

                    // Calculate local position relative to group center
                    const center = calculateGroupCenter();
                    plane.mesh.position.copy(worldPos).sub(center);

                    // Add to group
                    selectedPlaneGroup.add(plane.mesh);
                });

                // Position group at center
                const center = calculateGroupCenter();
                selectedPlaneGroup.position.copy(center);
            } else {
                // For existing group, just add any new planes
                selectedPlanes.forEach(plane => {
                    if (plane.mesh.parent !== selectedPlaneGroup) {
                        const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                        originalPositions.set(plane, {
                            worldPosition: worldPos.clone(),
                            parent: plane.mesh.parent
                        });

                        const center = selectedPlaneGroup.position;
                        plane.mesh.position.copy(worldPos).sub(center);
                        selectedPlaneGroup.add(plane.mesh);
                    }
                });
            }
            captureState();
        }

        function calculateGroupCenter() {
            const center = new THREE.Vector3();
            selectedPlanes.forEach(plane => {
                if (originalPositions.has(plane)) {
                    center.add(originalPositions.get(plane).worldPosition);
                } else {
                    center.add(plane.mesh.getWorldPosition(new THREE.Vector3()));
                }
            });
            center.divideScalar(selectedPlanes.length);
            return center;
        }

        function ungroupPlanes() {
            if (!selectedPlaneGroup) return;

            // Restore planes to their original positions and parents
            selectedPlanes.forEach(plane => {
                const original = originalPositions.get(plane);
                if (original) {
                    // Remove from group first
                    selectedPlaneGroup.remove(plane.mesh);

                    // Add back to original parent (usually the scene)
                    original.parent.add(plane.mesh);

                    // Restore world position
                    plane.mesh.position.copy(original.worldPosition);

                    // Update plane data to match world position
                    plane.x = plane.mesh.position.x;
                    plane.y = plane.mesh.position.y;
                    plane.z = plane.mesh.position.z;
                }
            });

            // Clean up the group
            scene.remove(selectedPlaneGroup);
            selectedPlaneGroup = null;
            originalPositions.clear();

            // Update GUI to reflect changes
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }
            captureState();
        }


        // Dragging variables
        let isDragging = false;
        let activeAxis = null;
        let dragPlane = new THREE.Plane();
        let dragOffset = new THREE.Vector3();
        let state_control = false;
        const raycaster1 = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let transformControlss = null;

        // Initialize transform controls
        function initTransformControls() {
            transformControlss = new THREE.TransformControls(activeCamera, renderer.domElement);
            transformControlss.setSpace('local');
            transformControlss.setMode('translate');
            transformControlss.size = 0.5;
            transformControlss.setTranslationSnap(0.1);  // Snap translation to 0.1 units
            transformControlss.setRotationSnap(Math.PI / 180); // Snap rotation to 10 degrees
            transformControlss.setScaleSnap(0.05); // Snap scaling to 0.05 units (5% increments)

            transformControlss.showX = true;
            transformControlss.showY = true;
            transformControlss.showZ = true;
            scene.add(transformControlss);

            // Disable orbit controls when transforming
            transformControlss.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
                // When dragging ends (event.value === false)
                if (!event.value && selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                    // Commit the group transformation to individual planes
                    commitGroupTransform();
                }
            });

            transformControlss.addEventListener('objectChange', function () {
                if (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                    // Update all planes when group moves
                    selectedPlanes.forEach(plane => {
                        plane.x = plane.mesh.position.x + selectedPlaneGroup.position.x;
                        plane.y = plane.mesh.position.y + selectedPlaneGroup.position.y;
                        plane.z = plane.mesh.position.z + selectedPlaneGroup.position.z;
                    });
                } else if (selectedPlanes.length > 0 &&
                    transformControlss.object === selectedPlanes[selectedPlanes.length - 1].mesh) {
                    updatePlaneDataFromTransform();
                }
                if (selectedPlanes.length > 0) {
                    updateGUI(selectedPlanes[selectedPlanes.length - 1]);
                }
                captureState();
            });
        }

        function commitGroupTransform() {
            if (!selectedPlaneGroup || selectedPlanes.length === 0) return;

            // Calculate the total transformation
            const groupPosition = selectedPlaneGroup.position.clone();

            // Update each plane's world position
            selectedPlanes.forEach(plane => {
                // Calculate new world position
                const newWorldPos = new THREE.Vector3().addVectors(
                    plane.mesh.position,
                    groupPosition
                );

                // Update plane data
                plane.x = newWorldPos.x;
                plane.y = newWorldPos.y;
                plane.z = newWorldPos.z;

                // Update original positions (for future grouping)
                if (originalPositions.has(plane)) {
                    originalPositions.get(plane).worldPosition.copy(newWorldPos);
                }
            });

            // Reset group position to origin
            selectedPlaneGroup.position.set(0, 0, 0);

            // Update plane positions relative to the group (now at origin)
            selectedPlanes.forEach(plane => {
                plane.mesh.position.set(plane.x, plane.y, plane.z);
            });

            // Re-center the group
            updateGroupPosition();
            captureState();
        }

        function updateGroupPosition() {
            if (!selectedPlaneGroup || selectedPlanes.length < 2) return;

            // Calculate center point in world space
            const center = new THREE.Vector3();
            selectedPlanes.forEach(plane => {
                if (originalPositions.has(plane)) {
                    center.add(originalPositions.get(plane).worldPosition);
                } else {
                    center.add(new THREE.Vector3(plane.x, plane.y, plane.z));
                }
            });
            center.divideScalar(selectedPlanes.length);

            // Update group position
            selectedPlaneGroup.position.copy(center);

            // Update plane positions relative to group
            selectedPlanes.forEach(plane => {
                const worldPos = originalPositions.has(plane) ?
                    originalPositions.get(plane).worldPosition.clone() :
                    new THREE.Vector3(plane.x, plane.y, plane.z);

                plane.mesh.position.copy(worldPos).sub(center);
            });
        }

        function updatePlaneDataFromTransform() {
            if (selectedPlanes.length === 0) return;

            const planeData = selectedPlanes[selectedPlanes.length - 1];
            const mesh = planeData.mesh;

            // Update position
            planeData.x = planeData.mesh.position.x;
            planeData.y = planeData.mesh.position.y;
            planeData.z = planeData.mesh.position.z;

            // Update rotation (convert to degrees)
            planeData.angle = Math.abs(mesh.rotation.y * (180 / Math.PI)) < 1e-10 ? 0 : mesh.rotation.y * (180 / Math.PI);
            planeData.incline = Math.abs(mesh.rotation.x * (180 / Math.PI)) < 1e-10 ? 0 : mesh.rotation.x * (180 / Math.PI);

            if (transformControlss.getMode() === 'scale') {
                planeData.width = planeData.defaultWidth * mesh.scale.x;
                planeData.height = planeData.defaultHeight * mesh.scale.y;
            }

            // Update the GUI to reflect changes
            updateGUI(planeData);
            captureState();
        }

        // Call this after setting up your scene
        initTransformControls();

        function restoration() {
            if (state_control) {
                controls.enabled = true;
                controls.update();
                state_control = false;
            }
        }
        window.addEventListener("mousedown", restoration);
        window.addEventListener('keydown', (event) => {
            if (!transformControlss) return;

            switch (event.key.toLowerCase()) {
                case 'w': // Translate
                    transformControlss.setMode('translate');
                    transformControlss.showZ = true;
                    break;
                case 'e': // Scale
                    transformControlss.setMode('scale');
                    transformControlss.showZ = true;
                    break;
                case 'r': // Rotate
                    transformControlss.setMode('rotate');
                    transformControlss.showZ = false;
                    break;
            }
        });
        window.addEventListener("keydown", function (event) {
            if (event.key === "Delete") {
                deleteplanefn();
            }
        })

        // Add plane button
        const addplanebtn = document.getElementById("addplane");
        addplanebtn.addEventListener("click", function () {
            const newPlane = createPlane();
            updateGUI(newPlane);
            selectedPlane = newPlane;
            transformControlss.attach(newPlane.mesh);
        });


        // Export function
        document.getElementById('exportBtn').addEventListener('click', exportScene);

        function exportScene() {
            const sceneData = {
                version: '1.0',
                imagePlane: {
                    visible: imagePlane.visible,
                    position: imagePlane.position.toArray(),
                    rotation: imagePlane.rotation.toArray(),
                    scale: imagePlane.scale.toArray(),
                    geometry: {
                        width: imagePlane.geometry.parameters.width,
                        height: imagePlane.geometry.parameters.height
                    },
                    texture: imagePlane.material.map ? imagePlane.material.map.image.currentSrc : null
                },
                planes: planes.map(plane => ({
                    name: plane.name,
                    position: plane.mesh.position.toArray(),
                    rotation: plane.mesh.rotation.toArray(),
                    scale: plane.mesh.scale.toArray(),
                    width: plane.width,
                    height: plane.height,
                    color: plane.color
                })),
                scalingFactor: scalingdist ? {
                    measuredDistance: scalingDistance,
                    inputValue: document.getElementById('scalinginput').value
                } : null
            };

            const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'scene_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import function
        // document.getElementById('importBtn').addEventListener('click', () => {
        //     document.getElementById('importFile').click();
        // });

        document.getElementById('importFile').addEventListener('change', importScene);

        function importScene(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const sceneData = JSON.parse(e.target.result);
                    loadSceneData(sceneData);
                } catch (error) {
                    console.error('Error parsing scene file:', error);
                    alert('Error loading scene file');
                }
            };
            reader.readAsText(file);
        }

        async function loadSceneData(sceneData) {
            // Clear existing scene
            while (planes.length) {
                deleteplanefn();
            }

            // Load image plane
            if (sceneData.imagePlane.texture) {
                await loadImageTexture(sceneData.imagePlane.texture);

                imagePlane.position.fromArray(sceneData.imagePlane.position);
                imagePlane.rotation.fromArray(sceneData.imagePlane.rotation);
                imagePlane.scale.fromArray(sceneData.imagePlane.scale);
                imagePlane.visible = sceneData.imagePlane.visible;

                // Update geometry
                imagePlane.geometry.dispose();
                imagePlane.geometry = new THREE.PlaneGeometry(
                    sceneData.imagePlane.geometry.width,
                    sceneData.imagePlane.geometry.height
                );
            }

            // Load planes
            sceneData.planes.forEach(planeData => {
                const newPlane = createPlane(planeData.width, planeData.height);
                newPlane.name = planeData.name || `Plane ${planes.length}`;
                newPlane.mesh.position.fromArray(planeData.position);
                newPlane.mesh.rotation.fromArray(planeData.rotation);
                newPlane.mesh.scale.fromArray(planeData.scale);
                newPlane.color = planeData.color;
                newPlane.mesh.material.color.setHex(planeData.color);
                updateGUI(newPlane);
            });

            // Load scaling data
            if (sceneData.scalingFactor) {
                scalingDistance = sceneData.scalingFactor.measuredDistance;
                document.getElementById('scalinginput').value = sceneData.scalingFactor.inputValue;
            }

            alert('Scene imported successfully!');
        }

        async function loadImageTexture(imageUrl) {
            return new Promise((resolve, reject) => {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(imageUrl,
                    (texture) => {
                        imagePlane.material.map = texture;
                        imagePlane.material.needsUpdate = true;
                        imagePlane.visible = true;

                        // Update aspect ratio
                        const img = new Image();
                        img.onload = function () {
                            aspect = img.width / img.height;
                            resolve();
                        };
                        img.src = imageUrl;
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading image:', error);
                        reject(error);
                    }
                );
            });
        }

        let dataarrayforcontour = null;

        function generatePointsOnPlane(plane, rows = 11, cols = 11) {
            const points = [];
            const width = plane.width;
            const height = plane.height;

            // Calculate step sizes
            const xStep = width / (cols - 1);
            const zStep = height / (rows - 1);

            // Create rotation matrix from plane's rotation and inclination
            const makeHorizontal = new THREE.Matrix4().makeRotationX(-Math.PI / 2);
            const rotationY = new THREE.Matrix4().makeRotationY(plane.angle * Math.PI / 180);
            const rotationX = new THREE.Matrix4().makeRotationX(plane.incline * Math.PI / 180);
            const rotationMatrix = new THREE.Matrix4()
                .multiply(makeHorizontal)
                .multiply(rotationX)
                .multiply(rotationY);

            // Generate grid points
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Calculate local position (centered)
                    const xLocal = (col * xStep) - (width / 2);
                    const zLocal = (row * zStep) - (height / 2);
                    const yLocal = 0; // On the plane surface

                    // Create vector and apply rotation
                    const point = new THREE.Vector3(xLocal, yLocal, zLocal);
                    point.applyMatrix4(rotationMatrix);

                    // Add plane position offset
                    point.x += plane.x;
                    point.y += plane.y;
                    point.z += plane.z;

                    points.push({
                        id: row * cols + col + 1,
                        position: {
                            x: parseFloat(point.x.toFixed(4)),
                            y: parseFloat(point.y.toFixed(4)),
                            z: parseFloat(point.z.toFixed(4))
                        },
                        localGrid: {
                            row: row + 1,
                            column: col + 1
                        }
                    });
                }
            }

            return points;
        }

        function Pointsinfo() {
            const exportData = planes.map(plane => {
                const points = generatePointsOnPlane(plane).map(point => [
                    point.position.x,
                    point.position.y,
                    point.position.z
                ]);

                return {
                    [plane.name || "Unnamed"]: points
                };
            });

            // Create a JSON string with pretty formatting (2-space indentation)
            const jsonString = JSON.stringify(exportData, null, 2);

            // Create a Blob with the JSON data
            const blob = new Blob([jsonString], { type: 'application/json' });

            // Create a download link
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `planes_export_${new Date().toISOString().slice(0, 10)}.json`;

            // Trigger the download
            document.body.appendChild(a);
            a.click();

            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        document.getElementById("calculate").addEventListener("click", Pointsinfo);

        // Add this function to handle the contour generation
        function addContourToSelectedPlane() {
            if (!selectedPlane) {
                alert("Please select a plane first");
                return;
            }

            // Create SVG for contour plot (hidden)
            const svg = d3.select("#contour-svg");
            svg.selectAll("*").remove(); // Clear any existing content

            const svgWidth = +svg.attr("width");
            const svgHeight = +svg.attr("height");

            // Generate sample data (replace with your actual data)
            const data = {
                width: 2,
                height: 2,
                values: Array.from({ length: 4 }, () => Math.random() * 10)
            };

            console.log(data.values);

            dataarrayforcontour = data.values;
            const n = data.width;
            const m = data.height;
            const path = d3.geoPath().projection(d3.geoIdentity().scale(svgWidth / n));
            const contours = d3.contours().size([n, m]);
            const color = d3.scaleSequential(d3.interpolateTurbo).domain(d3.extent(data.values)).nice();

            svg.append("g")
                .attr("stroke", "black")
                .selectAll()
                .data(color.ticks(20))
                .join("path")
                .attr("d", d => path(contours.contour(data.values, d)))
                .attr("fill", d => color(d));

            // Convert SVG to Canvas
            const canvas = document.createElement('canvas');
            canvas.width = svgWidth;
            canvas.height = svgHeight;
            const ctx = canvas.getContext('2d');

            // Serialize SVG to string
            const svgString = new XMLSerializer().serializeToString(svg.node());
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            // Create image from SVG
            const img = new Image();
            img.onload = function () {
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);

                // Create texture from canvas and apply to selected plane
                const texture = new THREE.CanvasTexture(canvas);
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

                // Update the selected plane's material
                selectedPlane.mesh.material.map = texture;
                selectedPlane.mesh.material.needsUpdate = true;
                selectedPlane.mesh.material.color.set(0xffffff); // Reset color for proper texture display
            };
            img.src = url;
        }

        let clipboard = null; // Will store copied planes
        let isCtrlPressed = false; // Track Ctrl key state
        // Add these near your other key listeners
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Control') {
                isCtrlPressed = true;
            }
            // Add copy/paste shortcuts (Ctrl+C, Ctrl+V)
            if (isCtrlPressed && event.key === 'c') {
                copySelected();
            }
            if (isCtrlPressed && event.key === 'v') {
                pasteFromClipboard();
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'Control') {
                isCtrlPressed = false;
            }
        });

        function copySelected() {
            if (selectedPlanes.length === 0) return;

            clipboard = {
                isGroup: selectedPlaneGroup !== null,
                planes: selectedPlanes.map(plane => ({
                    width: plane.defaultWidth,
                    height: plane.defaultHeight,
                    position: plane.mesh.position.clone(),
                    rotation: plane.mesh.rotation.clone(),
                    scale: plane.mesh.scale.clone(),
                    color: plane.color,
                    temperature: plane.temperature
                })),
                relativePositions: selectedPlaneGroup ?
                    selectedPlanes.map(plane => plane.mesh.position.clone()) :
                    null
            };
            console.log('Copied selection to clipboard');
            captureState();
        }


        function pasteFromClipboard() {
            if (!clipboard) return;

            // Clear current selection
            planes.forEach(p => p.mesh.material.color.setHex(p.color));
            selectedPlanes = [];
            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            // Create new planes from clipboard
            const newPlanes = [];
            const offset = new THREE.Vector3(1, 0, 1); // Small offset for pasted copies

            clipboard.planes.forEach((planeData, index) => {
                const newPlane = createPlane(planeData.width, planeData.height);

                // Set properties from copied plane
                newPlane.mesh.position.copy(planeData.position).add(offset);
                newPlane.mesh.rotation.copy(planeData.rotation);
                newPlane.mesh.scale.copy(planeData.scale);
                newPlane.mesh.material.color.setHex(planeData.color);

                // Update plane data with correct values
                newPlane.width = planeData.width * planeData.scale.x;
                newPlane.height = planeData.height * planeData.scale.y;
                newPlane.defaultWidth = planeData.width;
                newPlane.defaultHeight = planeData.height;
                newPlane.x = newPlane.mesh.position.x;
                newPlane.y = newPlane.mesh.position.y;
                newPlane.z = newPlane.mesh.position.z;
                newPlane.angle = planeData.rotation.y * (180 / Math.PI);
                newPlane.incline = planeData.rotation.x * (180 / Math.PI);
                newPlane.color = planeData.color;
                newPlane.temperature = planeData.temperature;

                // Select the new plane
                newPlanes.push(newPlane);
                newPlane.mesh.material.color.setHex(0xffff00);
            });

            selectedPlanes = [...newPlanes];

            // If original was a group, recreate the group structure
            if (clipboard.isGroup && selectedPlanes.length > 1) {
                createOrUpdateGroup();

                // Apply relative positions if available
                if (clipboard.relativePositions) {
                    selectedPlanes.forEach((plane, index) => {
                        if (clipboard.relativePositions[index]) {
                            plane.mesh.position.copy(clipboard.relativePositions[index]);
                        }
                    });
                    updateGroupPosition();
                }
            }

            // Update transform controls and GUI
            updateTransformControls();
            if (selectedPlanes.length > 0) {
                // Force GUI update with the correct values
                const lastPlane = selectedPlanes[selectedPlanes.length - 1];
                updateGUI(lastPlane);

                // Also update the mesh's userData to match
                lastPlane.mesh.userData = lastPlane;
            }

            console.log('Pasted from clipboard');
            captureState();
        }


        function showContourToSelectedPlane() {
            if (!selectedPlane) {
                alert("Please select a plane first");
                return;
            }

            // Get modal elements
            const modal = document.getElementById("contourModal");
            const modalImg = document.getElementById("contourImage");
            const valueDisplay = document.getElementById("valueDisplay");
            const span = document.getElementsByClassName("close")[0];

            // Generate the contour data (same as in your contourgenerator function)
            const contourData = {
                width: 2,
                height: 2,
                values: dataarrayforcontour
            };

            // Create SVG for contour plot (hidden)
            const svg = d3.select("#contour-svg");
            svg.selectAll("*").remove();
            const svgWidth = +svg.attr("width");
            const svgHeight = +svg.attr("height");

            const n = contourData.width;
            const m = contourData.height;
            const path = d3.geoPath().projection(d3.geoIdentity().scale(svgWidth / n));
            const contours = d3.contours().size([n, m]);
            const color = d3.scaleSequential(d3.interpolateTurbo).domain(d3.extent(contourData.values)).nice();

            svg.append("g")
                .attr("stroke", "black")
                .selectAll()
                .data(color.ticks(20))
                .join("path")
                .attr("d", d => path(contours.contour(contourData.values, d)))
                .attr("fill", d => color(d));

            // Convert SVG to Canvas
            const canvas = document.createElement('canvas');
            canvas.width = svgWidth;
            canvas.height = svgHeight;
            const ctx = canvas.getContext('2d');

            // Serialize SVG to string
            const svgString = new XMLSerializer().serializeToString(svg.node());
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            // Create image from SVG
            const img = new Image();
            img.onload = function () {
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);

                // Set the image source and show the modal
                modalImg.src = canvas.toDataURL();
                modal.style.display = "block";

                // Create value map from original data
                const valueMap = [];
                for (let y = 0; y < m; y++) {
                    valueMap[y] = [];
                    for (let x = 0; x < n; x++) {
                        valueMap[y][x] = contourData.values[y * n + x];
                    }
                }

                // Zoom variables
                let scale = 1;
                const minScale = 0.5;
                const maxScale = 5;
                const zoomFactor = 0.1;

                // Mouse wheel zoom handler
                function handleWheel(e) {
                    e.preventDefault();

                    // Calculate new scale
                    if (e.deltaY < 0) {
                        scale = Math.min(scale + zoomFactor, maxScale);
                    } else {
                        scale = Math.max(scale - zoomFactor, minScale);
                    }

                    // Apply the scale
                    modalImg.style.transform = `translate(-50%, -50%) scale(${scale})`;
                    modalImg.style.cursor = scale > 1 ? 'grab' : 'zoom-in';
                }

                // Mouse move handler to show values
                function handleMouseMove(e) {
                    const rect = modalImg.getBoundingClientRect();

                    // Calculate position relative to the scaled image
                    const imgX = (e.clientX - (rect.left + rect.width / 2 - (rect.width * scale) / 2)) / (rect.width * scale);
                    const imgY = (e.clientY - (rect.top + rect.height / 2 - (rect.height * scale) / 2)) / (rect.height * scale);

                    if (imgX >= 0 && imgX <= 1 && imgY >= 0 && imgY <= 1) {
                        // Map to data coordinates
                        const dataX = Math.floor(imgX * n);
                        const dataY = Math.floor(imgY * m);

                        // Clamp to valid range
                        const x = Math.max(0, Math.min(n - 1, dataX));
                        const y = Math.max(0, Math.min(m - 1, dataY));

                        const value = valueMap[y][x];

                        // Position display above cursor when near bottom
                        const displayAbove = (e.clientY > window.innerHeight - 100);

                        valueDisplay.style.display = 'block';
                        valueDisplay.style.left = `${e.clientX + 15}px`;
                        valueDisplay.style.top = `${e.clientY + (displayAbove ? -40 : 15)}px`;
                        valueDisplay.textContent = `Value: ${value.toFixed(2)}`;
                    } else {
                        valueDisplay.style.display = 'none';
                    }
                }

                // Mouse leave handler
                function handleMouseLeave() {
                    valueDisplay.style.display = 'none';
                }

                // Add event listeners
                modalImg.addEventListener('wheel', handleWheel, { passive: false });
                modalImg.addEventListener('mousemove', handleMouseMove);
                modalImg.addEventListener('mouseleave', handleMouseLeave);

                // Cleanup function
                function cleanup() {
                    modalImg.removeEventListener('wheel', handleWheel);
                    modalImg.removeEventListener('mousemove', handleMouseMove);
                    modalImg.removeEventListener('mouseleave', handleMouseLeave);
                    modal.style.display = "none";
                    modalImg.style.transform = 'translate(-50%, -50%) scale(1)';
                }

                // Close handlers
                span.onclick = cleanup;
                modal.onclick = function (e) {
                    if (e.target === modal) cleanup();
                };
                modalImg.onclick = function (e) {
                    e.stopPropagation();
                };
            };
            img.src = url;
        }

        // Add event listener to your contour button
        document.getElementById("contourgenerator").addEventListener("click", addContourToSelectedPlane);
        document.getElementById("detail").addEventListener("click", showContourToSelectedPlane);



        // Replace the current captureState function with this:
        function captureState(force = false) {
            // Don't capture during normal operations unless forced
            if ((transformControlss && transformControlss.dragging) ||
                (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup)) {
                if (!force) return;
            }

            const state = planes.map(plane => ({
                position: plane.mesh.position.clone(),
                rotation: plane.mesh.rotation.clone(),
                scale: plane.mesh.scale.clone(),
                width: plane.width,
                height: plane.height,
                color: plane.color,
                temperature: plane.temperature,
                name: plane.name
            }));

            // If we're in the middle of history (after some undos), discard future states
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            // Don't capture duplicate states
            if (history.length > 0) {
                const lastState = history[history.length - 1];
                if (JSON.stringify(lastState) === JSON.stringify(state)) {
                    console.log("Skipping duplicate state capture");
                    return;
                }
            }

            history.push(state);
            historyIndex = history.length - 1;
            console.log(`State captured (${historyIndex + 1}/${history.length})`);

            // Limit history size
            if (history.length > MAX_HISTORY_STEPS) {
                history.shift();
                historyIndex--;
                console.log("Trimmed history to max size");
            }
        }
        // Add this event listener to capture state when dragging ends
        transformControlss.addEventListener('dragging-changed', function (event) {
            controls.enabled = !event.value;
            if (!event.value) {
                captureState(true); // Force capture when dragging ends
            }
            console.log('State captured. History size:', history.length);

        });

        // Replace the current restoreState function with this:
        // Replace the current restoreState function with this improved version
        function restoreState(index) {
            if (index < 0 || index >= history.length) return;

            const state = history[index];

            // First, just clear the selection
            selectedPlanes = [];
            transformControlss.detach();

            // Update existing planes instead of recreating them
            for (let i = 0; i < state.length; i++) {
                const planeState = state[i];

                // If we have an existing plane at this index, update it
                if (i < planes.length) {
                    const plane = planes[i];

                    // Update properties
                    plane.mesh.position.copy(planeState.position);
                    plane.mesh.rotation.copy(planeState.rotation);
                    plane.mesh.scale.copy(planeState.scale);
                    plane.width = planeState.width;
                    plane.height = planeState.height;
                    plane.color = planeState.color;
                    plane.temperature = planeState.temperature;
                    plane.name = planeState.name;
                    plane.mesh.material.color.setHex(planeState.color);

                    // Update derived properties
                    plane.x = planeState.position.x;
                    plane.y = planeState.position.y;
                    plane.z = planeState.position.z;
                    plane.angle = planeState.rotation.y * (180 / Math.PI);
                    plane.incline = planeState.rotation.x * (180 / Math.PI);
                } else {
                    // If we need more planes than exist, create new ones
                    const newPlane = createPlane(planeState.width, planeState.height);
                    newPlane.mesh.position.copy(planeState.position);
                    newPlane.mesh.rotation.copy(planeState.rotation);
                    newPlane.mesh.scale.copy(planeState.scale);
                    newPlane.color = planeState.color;
                    newPlane.temperature = planeState.temperature;
                    newPlane.name = planeState.name;
                    newPlane.mesh.material.color.setHex(planeState.color);

                    // Update derived properties
                    newPlane.x = planeState.position.x;
                    newPlane.y = planeState.position.y;
                    newPlane.z = planeState.position.z;
                    newPlane.angle = planeState.rotation.y * (180 / Math.PI);
                    newPlane.incline = planeState.rotation.x * (180 / Math.PI);
                }
            }

            // If there are more planes than in the history state, remove the extras
            while (planes.length > state.length) {
                const plane = planes.pop();
                scene.remove(plane.mesh);
                plane.mesh.geometry.dispose();
                plane.mesh.material.dispose();
            }

            // Update GUI
            gui.destroy();
            gui = new dat.GUI();
        }



        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, activeCamera);
        }
        animate();

        // Handle window resize
        window.addEventListener("resize", () => {
            cameras.perspective.aspect = window.innerWidth / window.innerHeight;
            cameras.perspective.updateProjectionMatrix();
            activeCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateOrthoCameras();

            // Update transform controls if they exist
            if (transformControlss) {
                transformControlss.camera = activeCamera;
            }
        });
    </script>
</body>

</html>
